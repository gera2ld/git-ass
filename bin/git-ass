#!/usr/bin/env python3

import os
import sys
import json
import argparse
import subprocess

parser = argparse.ArgumentParser(description='Git branch helper')
parser.set_defaults(name=None, handle=None)
sub_parsers = parser.add_subparsers()

def handler(parser_name, *k, specify_branch=False, **kw):
    sub_parser = sub_parsers.add_parser(parser_name, *k, **kw)
    sub_parser.add_argument('-s', '--silent', help='Suppress errors', action='store_true')
    if specify_branch:
        sub_parser.add_argument('-n', '--name', help='Specify branch name')
    def wrap(handle):
        def wrapped_handle(*k, **kw):
            try:
                return handle(*k, **kw)
            except AssertionError:
                if not args.silent: raise
        sub_parser.set_defaults(handle=wrapped_handle)
        return wrapped_handle
    return wrap

def branch_property(key):
    def getx(self):
        return self.data.get(key) or ''
    def setx(self, value=None):
        self.data[key] = value
    def delx(self):
        self.data.pop(key, None)
    return property(getx, setx, delx)

class Branch:
    TYPE_REL = 'release'
    TYPE_DEV = 'development'

    name = branch_property('name')
    desc = branch_property('desc')
    alias = branch_property('alias')
    base = branch_property('base')

    def __init__(self, store, **kw):
        self.store = store
        self.data = {}
        self.data.update(kw)

    def __repr__(self):
        return f'<Branch name={self.name} alias={self.alias}>'

    def __str__(self):
        alias = f'({self.alias})' if self.alias else ''
        base = f'[{self.base}]' if self.base else ''
        return f'{self.name} {alias}\t{base}\t{self.desc}'

    def dump(self):
        return self.data.copy()

    def update(self, info):
        for key, value in info.items():
            if value is None: continue
            self.data[key] = value

class Store:
    def __init__(self, filename=None):
        self.filename = filename
        self.data = {}
        self.alias = {}
        try:
            self.store = json.load(open(filename, encoding='utf-8'))
        except FileNotFoundError:
            self.store = {}
        branch_list = self.store.get(cwd, ())
        for branch_info in branch_list:
            branch = Branch(self, **branch_info)
            self.data[branch.name] = branch
            alias = branch.alias
            if alias:
                self.alias[alias] = branch

    def add(self, merge=True, **branch_info):
        name = branch_info['name']
        old_branch = self.data.get(name)
        if old_branch is None:
            branch = Branch(self, **branch_info)
            self.data[name] = branch
            print('New branch added:')
        elif not merge:
            raise ValueError('Branch already exists')
        else:
            alias = old_branch.alias
            if alias:
                self.alias.pop(alias, None)
            old_branch.update(branch_info)
            print('Branch updated:')
            branch = old_branch
        alias = branch.alias
        if alias:
            self.alias[alias] = branch
        print(branch)

    def remove(self, name):
        branch = self.data.pop(name, None)
        if branch is not None:
            alias = branch.alias
            if alias:
                self.alias.pop(alias, None)

    def dump(self):
        return [branch.dump() for branch in self.data.values()]

    def dump_to_file(self):
        data = self.dump()
        self.store[cwd] = data
        json.dump(self.store, open(self.filename, 'w', encoding='utf-8'), ensure_ascii=False)

    def find(self, name):
        return self.data.get(name) or self.alias.get(name)

def get_branch_name():
    name = args.name
    if name is None:
        stdout = subprocess.run(['git', 'branch'], capture_output=True, encoding='utf-8').stdout
        for item in stdout.split('\n'):
            if item.startswith('* '):
                name = item[2:]
                break
    return name

@handler('info', help='Show information of specified branch', specify_branch=True)
def info():
    current_branch_name = get_branch_name()
    branch = store.find(current_branch_name)
    assert branch is not None, 'Branch info not found'
    if args.property is None:
        ancestors = [branch]
        names = set()
        names.add(branch.name)
        base = branch
        while True:
            assert base.base not in names
            names.add(base.base)
            base = store.find(base.base)
            if base is None: break
            ancestors.append(base)
        for i, branch in enumerate(reversed(ancestors)):
            print('  ' * i, branch, sep='')
    else:
        print(getattr(branch, args.property, None) or '')

sub_parser = sub_parsers.choices['info']
sub_parser.add_argument('-p', '--property', help='Specify property name')

@handler('add', aliases=['update'], help='Add or update information of specified branch', specify_branch=True)
def add():
    current_branch_name = get_branch_name()
    base = None
    if args.base:
        base_branch = store.find(args.base)
        assert base_branch, 'Base branch not found'
        base = base_branch.name
    store.add(
        alias=args.alias,
        base=base,
        name=current_branch_name,
        desc=args.description)
    store.dump_to_file()

sub_parser = sub_parsers.choices['add']
sub_parser.add_argument('-B', '--base', help='Set name of base branch')
sub_parser.add_argument('-a', '--alias', help='Set alias of current branch')
sub_parser.add_argument('-d', '--description', help='Set description of a branch')

@handler('remove', aliases=['rm'], help='Remove information of specified branch', specify_branch=True)
def remove():
    current_branch_name = get_branch_name()
    branch = store.find(current_branch_name)
    if branch is not None:
        store.remove(current_branch_name)
        print(f'Branch removed: {current_branch_name}')
    else:
        print('Branch information is not found')
    store.dump_to_file()

@handler('rebase', help='Rebase current branch on top of its base branch')
def rebase():
    current_branch_name = get_branch_name()
    branch = store.find(current_branch_name)
    assert store.find(branch.base) is not None, 'Base branch not found'
    subprocess.run(['git', 'fetch'])
    subprocess.run(['git', 'rebase', f'origin/{branch.base}'])

@handler('list', help='List branches of interest')
def list_branches():
    current_branch_name = get_branch_name()
    parent_map = {}
    child_map = {}
    for branch in store.data.values():
        base_branch = store.find(branch.base)
        if base_branch is not None:
            parent_map[branch.name] = branch.base
            child_map.setdefault(branch.base, []).append(branch.name)
        parent_map.setdefault(branch.name, None)
    def dump_branch(branch_name, indent=0):
        branch = store.find(branch_name)
        mark = '* ' if branch_name == current_branch_name else '  '
        print(mark, '  ' * indent, branch, sep='')
        children = child_map.get(branch_name)
        if children:
            for child in sorted(children):
                dump_branch(child, indent + 1)
    for branch_name in sorted(key for (key, value) in parent_map.items() if value is None):
        dump_branch(branch_name)

@handler('checkout', aliases=['co'], help='Check out a branch based on name or alias')
def checkout():
    branch = store.find(args.branch)
    assert branch is not None, 'Branch not found'
    subprocess.run(['git', 'checkout', branch.name])

sub_parser = sub_parsers.choices['checkout']
sub_parser.add_argument('branch', help='The branch name to check out')

@handler('prune', help='Prune removed branches')
def prune():
    subprocess.run(['git', 'fetch', '--all', '--prune'])
    stdout = subprocess.run(['git', 'branch', '-r'], capture_output=True, encoding='utf-8').stdout
    remote_branches = set(name.partition('/')[2] for name in stdout.split())
    to_remove = set()
    to_drop_base = set()
    for branch in store.data.values():
        branch_name = branch.name
        if '/' not in branch_name and branch_name not in remote_branches:
            to_remove.add(branch_name)
    for branch in store.data.values():
        branch_base = branch.base
        if branch_base in to_remove:
            to_drop_base.add(branch)
    if to_remove:
        print('Prune branches:')
        for branch_name in sorted(to_remove):
            print('-', branch_name)
            store.remove(branch_name)
        if to_drop_base:
            print('Drop base:')
            for branch in sorted(to_drop_base, key=lambda b: b.name):
                print('-', branch.name)
                del branch.base
        store.dump_to_file()
    else:
        print('No branch to prune')

@handler('autocomplete', add_help=False)
def autocomplete():
    def get_command(index):
        if index < len(args.commands):
            return args.commands[index]
        return ''
    first = get_command(0)
    if not first:
        items = []
        choices = sub_parsers.choices
        for key in sorted(choices.keys()):
            parser = choices[key]
            if parser.add_help:
                items.append(key)
        complete = ' '.join(items)
        print(f'2: :({complete})')
    else:
        if first in ('checkout', 'co'):
            complete = ' '.join(list(store.alias.keys()) + list(store.data.keys()))
            print(f'*: :({complete})')

sub_parser = sub_parsers.choices['autocomplete']
sub_parser.add_argument('commands', nargs='*', default=())

appdir = os.path.dirname(os.path.dirname(__file__))
datadir = os.path.join(appdir, 'data')
cwd = os.getcwd()

os.makedirs(datadir, exist_ok=True)
store = Store(os.path.join(datadir, 'data.json'))

args = parser.parse_args()

if args.handle is None:
    parser.print_help()
else:
    args.handle()
